# <center>上机报告-1</center>
<center>数算B 谢胡睿 2400014151</center>

## 题目
### 1.题目背景
给定无向连通图 G 和 m 种不同的颜色。用这些颜色为图 G 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 G 中每条边的2个顶点着不同颜色，则称这个图是 m 可着色的。着色问题是对于给定图 G ，找出使得这个图 m 可着色的最小 m 。
### 2.题目描述
对于给定的无向连通图 G ，编程计算使得这个图 m 可着色的最小 m。
### 3.输入格式
第 1 行有 2 个正整数 n,k，表示给定的图 G 有 n 个顶点和 k 条边。顶点编号为 1,2,…,n。接下来的 k 行中，每行有 2 个正整数 u,v，表示图 G 的一条边 (u,v)。

## Solution
### 总体描述
#### 第一种思路-着色
在图里面不断尝试每一个点的颜色，最终判断颜色的数量。
当测试某一个点用颜色mi是否合适，需要判断和它相邻的节点，是否颜色相同。
如果相同，就换颜色。不同，表明当下颜色是一个可行的（不一定最优）
需要回溯判断，毕竟当前颜色不一定是最优的颜色。
#### 第二种思路-划分【不最优，但可行】
通过把图里面节点进行划分，使得相同划分内没有边连接。
维护一个队列来完成。
### 设计与实现
**使用第一种思路**
#### 准备
数据结构：使用邻接矩阵存储边。用一个color数组存储颜色。
从1开始循环到n，从而判断能否完成最小的着色方案。
使用回溯法，不断调整颜色，从而获得最优解。
语言为c++。
大致需要四个函数，输入，建边，判断是否能够着色（通过边判断），以及一个较为复杂的回溯递归，进行最小着色。
#### 回溯递归的内容
需要有当前最多的颜色m，边的关系g，总共数目n，以及目前已经着色的进度x
**如果x>n，则表明已经完成着色，就返回true**
从1-m种颜色不断对节点x进行着色，
**如果能够着色，就改变color值，并且x+1进行着色。**
**如果不能，就返回false。**
在循环体最后回溯，防止干扰颜色。
#### 结果
主程序中循环得到的第一个可行的解，就是最小的解。
### 遇到的问题
#### 书写input函数时传参graph错误
原因是仅仅写bool &graph是不行的，二维数组至少需要指定列
故应该是bool (&graph)[100][100]
#### 第一次测试，返回为1，答案错误
排查graph情况：没有问题
先排查出color函数中，没有return false（增加鲁棒性）
再排查color输出：没有问题
**后发现在paint_color函数中，把着色内容放入判断的第二重循环里，故而出错。**
改进后正常运行。
### 总结：
仍然需要仔细地理清循环之间的关系，本题思路中，需要先用循环内的一重循环判断是否有相同着色。之后才是着色。需要理清关系。

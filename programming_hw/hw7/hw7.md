# <center>上机报告-7</center>
<center>数算B 谢胡睿 2400014151</center>

## 题目
### 1.题目背景
排序。

### 2.题目描述
给定一个数组，输出其升序排序之后的结果。

### 3.输入格式
第一行为一个正整数$𝑁$，表示数组共有$𝑁$个数。
接下来 $1$ 行，包含以单个空格分隔的$𝑁$个整数。

### 4.输出格式
$1$行，以单个空格分隔的$𝑀$个整数，为按照升序排序后的结果。

### 输入输出样例
#### 输入
```cpp
5
5 4 3 2 1
```
#### 输出
```cpp
1 2 3 4 5
```

**数据范围和提示**
* 对于100%的数据, $N \times \log_2N \le 1,000,000$,且数据存在极端情况。
* 数组中的数为 $long$ 范围的(4 位)
* 评测限时 $1s$，无存储限制
* 本题任何除了结构体、默认的数组、链表之外的数据结构必须自行实现


## Solution
### 总体描述
由稳定性和时限要求，本题要求实现归并排序算法.

### 方案：归并排序 (Merge Sort)
#### 设计思路
1.  **基本原理**：
    *   **分解**：递归地分成两个各含 $N/2$ 个元素的子序列。
    *   **合并**：将两个已排序的子序列合并成一个升序序列。

2.  **数据结构 (`Arr`)**：
    *   `int num`: 存储数组中元素的数量。
    *   `long* nodes`:动态数组实现。
    *   **构造函数 `Arr(int n)`**。
    *   **析构函数 `~Arr()`**：释放内存。
    
## 优缺点
### 优点：
1.  **时间复杂度稳定**：归并排序在最坏、平均和最好情况下的时间复杂度均为 $O(N \log_2 N)$。
2.  **稳定性**：归并排序是稳定的排序算法。

### 缺点：
1.  **空间复杂度**：本次实现的归并排序不是原地的。递归调用本身也会消耗 $O(\log_2 N)$ 的栈空间。
2.  **动态内存分配开销**。

## 问题与挑战
### 1. 内存管理
*   **中间结果的释放**：
```cpp
    delete a;
    delete b;
```
*   **最终结果的释放**
*   **`Arr` 结构体自身的内存管理**：析构函数。
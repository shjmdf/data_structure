# 数据结构第一章 概论 - 期末复习笔记

## 1. 为什么要学习数据结构？ (P1-P5, P14)

* **核心思想**：数据结构是计算机组织和存储数据的方式，它直接影响算法的效率和程序的性能。学习数据结构是为了能够：
    * 理解数据在计算机中的表示和关系。
    * 设计出更有效率的算法来解决复杂问题。
    * 能够分析和选择最合适的数据结构来满足特定需求。
    * **“轮子为什么是圆的”**: 即使我们使用现成的库，也需要理解其底层原理。 [cite: 2]
    * **价值体现**: 优秀的算法和数据结构设计是高水平程序员与普通程序员的区别之一，尤其在处理全新问题时。 [cite: 2]
    * **科研与创新**: 能够将自己的想法和模型高效地实现和优化。 [cite: 3]

* **计算机处理的对象**：数据。 [cite: 4]
    * 数据之间存在逻辑关系。 [cite: 4]
    * 如何有效组织、存储数据。 [cite: 4]
    * 数据有哪些运算以及如何实现。 [cite: 4]

* **学习数据结构要解决的问题 (P14)**：
    * 非数值计算问题（如图、表、树）通常需要自定义数据结构。 [cite: 18]
    * 计算机语言通常只提供基本数据类型和构造手段（数组、结构、指针），复杂数据结构需自行实现。 [cite: 18]
    * 求解问题流程：分析需求 -> 建立抽象模型 -> 设计数据结构和算法 -> 编程实现。 [cite: 18]

## 2. 基本概念和术语 (P16-P21)

### 2.1 数据、数据元素、数据对象、数据类型 (P16)

* **数据 (Data)**：能被计算机识别、存储和处理的信息载体。 [cite: 20]
* **数据元素 (Data Element)**：数据的基本单位。 [cite: 20] 也称元素、结点、顶点、记录。 [cite: 20] 可由若干**数据项 (Data Item)** 组成（数据项是具有独立含义的最小标识单位）。 [cite: 20]
    * *例：学生成绩表中的一名学生记录是一个数据元素，该学生的姓名、学号、成绩等是数据项。*
* **数据对象 (Data Object)**：性质相同的数据元素的集合，是数据的一个子集。 [cite: 20]
    * *例：整数数据对象是所有整数的集合。*
* **数据类型 (Data Type)**：一个值的集合以及在这些值上定义的一组操作的总称。 [cite: 20]
    * **原子数据类型**：不可再分解的数据类型（如 `int`, `char`, `float`）。 [cite: 20]
    * **结构数据类型**：可以分解，由若干原子类型或结构类型组合而成（如数组、结构体）。 [cite: 20]

### 2.2 数据结构 (P17)

* **定义**：指数据之间的相互关系，即数据的组织形式。 [cite: 21]
* **三个方面**： [cite: 21]
    1.  **逻辑结构 (Logical Structure)**：数据元素之间的逻辑关系。 [cite: 21] 是从具体问题抽象出来的数学模型，与数据的存储无关。
        * 用二元组表示：`Data_Structure = (D, R)` [cite: 21]
            * `D`：数据元素的有限集合。
            * `R`：`D` 上关系的有限集合。
    2.  **存储结构 (Storage Structure / Physical Structure)**：数据元素及其关系在计算机内存中的映像与表示。 [cite: 21] 也称为物理结构。
    3.  **数据的运算 (Operations on Data)**：定义在逻辑结构上的一系列操作以及这些操作在存储结构上的实现。 [cite: 21] 运算的定义针对逻辑结构，但实现依赖于存储结构。 [cite: 21]

### 2.3 四种基本逻辑结构 (P18)

1.  **集合 (Set)**：数据元素除了“同属于一个集合”外，没有其他特定关系。 [cite: 22]
    * [图片：集合结构示意图]
2.  **线性结构 (Linear Structure)**：数据元素之间存在一对一的关系。 [cite: 22] 有唯一的开始和结束元素（除首尾外，每个元素有唯一前驱和唯一后继）。
    * *例：线性表、栈、队列、字符串。*
    * [图片：线性结构示意图]
3.  **树形结构 (Tree Structure)**：数据元素之间存在一对多的关系（层状结构）。 [cite: 22] 每个元素（除根节点外）有唯一前驱，但可以有多个后继。 [cite: 22]
    * *例：二叉树、普通树。*
    * [图片：树形结构示意图]
4.  **图状或网状结构 (Graph or Network Structure)**：数据元素之间存在多对多的关系。 [cite: 22] 元素之间的关系是任意的，每个元素可以有多个前驱和多个后继。 [cite: 22]
    * *例：交通网络图。*
    * [图片：图状结构示意图]

### 2.4 四种基本存储结构 (P19-P20)

1.  **顺序存储结构 (Sequential Storage Structure)**：
    * 把逻辑上相邻的结点存储在物理位置相邻的存储单元里。 [cite: 23]
    * 结点间的逻辑关系由存储单元的邻接关系来体现。 [cite: 23]
    * *优点：可以随机存取。缺点：插入删除操作可能需要移动大量元素。*
    * *例：数组。*
    * [图片：顺序存储示意图] [cite: 24]

2.  **链接存储结构 (Linked Storage Structure)**：
    * 不要求逻辑上相邻的结点在物理位置上亦相邻。 [cite: 23]
    * 结点间的逻辑关系由附加的指针字段表示。 [cite: 23]
    * *优点：插入删除操作方便。缺点：不能随机存取，需要额外空间存储指针。*
    * *例：链表。*
    * [图片：链接存储示意图] [cite: 24]

3.  **索引存储结构 (Indexed Storage Structure)**：
    * 在存储结点信息的同时，还建立附加的索引表来标识结点的地址。 [cite: 23]
    * 索引表由若干索引项组成，每项通常形式为：（关键字，地址）。
    * *优点：检索速度快。缺点：需要额外空间存储索引表，增加和删除数据时可能需要修改索引表。*
    * [图片：索引存储示意图] [cite: 24]

4.  **散列存储结构 (Hashing / Hash Storage Structure)**：
    * 根据结点的关键字直接计算出该结点的存储地址。 [cite: 23] 也称哈希存储。
    * *优点：检索、增加、删除操作通常很快。缺点：若散列函数不好，可能出现冲突，解决冲突会增加开销。*
    * [图片：散列存储示意图] [cite: 24]

**注意**：这四种存储结构既可单独使用，也可组合使用。 [cite: 23]

### 2.5 数据的运算 (P21)

* 定义在逻辑结构上的一系列操作。 [cite: 25]
* 具体实现基于存储结构。 [cite: 25]
* **常用运算**：检索 (Search)、插入 (Insert)、删除 (Delete)、定位 (Locate)、修改 (Modify)、排序 (Sort) 等。 [cite: 25]

## 3. 数据类型和抽象数据类型 (ADT) (P22-P25)

### 3.1 数据类型 (P22)

* 回顾：一个值的集合以及在这些值上定义的一组操作的总称。 [cite: 26]
* 隐含规定了程序执行期间变量的取值范围和允许的操作。 [cite: 26]

### 3.2 抽象数据类型 (Abstract Data Type, ADT) (P23-P25)

* **定义**：一个数学模型以及定义在该模型上的一组操作。 [cite: 27]
* **核心思想 (封装与信息隐藏)**：ADT 的定义仅取决于它的一组**逻辑特性**，而与其在计算机内的**表示和实现无关**。 [cite: 27] 用户只需知道 ADT 能做什么（操作），无需关心如何做（实现细节）。
* **三元组表示**：`ADT = (D, R, P)` [cite: 27]
    * `D`：数据对象 (Data Object)。 [cite: 27]
    * `R`：`D` 上的关系集合 (Relationships)。 [cite: 27]
    * `P`：对 `D` 的基本操作集合 (Operations)。 [cite: 27]
* **ADT 描述格式示例 (P23)**： [cite: 27]
    ```
    ADT 抽象数据类型名 {
        数据对象：<数据对象的定义>
        数据关系：<数据关系的定义>
        基本操作：<基本操作的定义> // 通常包括操作名、参数、初始条件、操作结果描述
    } ADT 抽象数据类型名
    ```
* **示例：线性表的抽象数据类型 (P24)** [cite: 28, 29]
    ```
    ADT LIST {
        数据对象：D = {a_i | a_i ∈ elemset, i = 1, 2, ..., n; n ≥ 0} // n个数据元素的有限序列 [cite: 28]
        数据关系：R = {<a_{i-1}, a_i> | a_{i-1}, a_i ∈ D, i = 2, ..., n} // 一对一的线性关系 [cite: 28]
        基本操作：
            SetNull(L)              // 置空线性表 [cite: 28]
            Length(L)               // 返回线性表长度 [cite: 28]
            Get(L, i)               // 获取第i个元素 [cite: 29]
            Locate(L, x)            // 查找元素x的位置 [cite: 29]
            Insert(L, x, i)         // 在第i个位置插入元素x [cite: 29]
            Delete(L, i)            // 删除第i个元素 [cite: 29]
    } ADT LIST
    ```
* **示例：圆的抽象数据类型 (P25)** [cite: 30]
    ```
    ADT circle is
        data
            float r; // 半径 [cite: 30]
        operations
            void constructor() // 构造一个圆 [cite: 30]
            float area () { return(3.14 * r * r); } // 计算面积 [cite: 30]
            float circumference() { return (2 * 3.14 * r); } // 计算周长 [cite: 30]
    end ADT circle;
    ```

## 4. 算法描述与算法评价 (P26-P34)

### 4.1 算法 (Algorithm) (P26)

* **定义**：对特定问题求解方法和步骤的一种描述，是指令的一组有限序列，其中每个指令表示一个或多个操作。 [cite: 31]
* **程序 = 算法 + 数据结构** (N.Wirth) [cite: 31]
* 选择好的数据结构，还需要好的算法。 [cite: 31]

### 4.2 算法的五个重要特性 (P26) [cite: 31]

1.  **有穷性 (Finiteness)**：算法必须在执行有限步之后终止，每一步都能在有限时间内完成。 [cite: 31]
2.  **确定性 (Definiteness)**：算法中每条指令必须有明确的含义，无二义性。 [cite: 31] 对于相同的输入，必须得到相同的输出。 [cite: 31]
3.  **可行性 (Effectiveness)**：算法中的所有操作都可以通过已经实现的基本运算执行有限次来实现。 [cite: 31]
4.  **输入 (Input)**：算法有零个或多个外部输入。 [cite: 31]
5.  **输出 (Output)**：算法有一个或多个输出。 [cite: 31]

### 4.3 描述算法的工具 (P27) [cite: 32]

* 自然语言、数学语言、约定的符号。 [cite: 32]
* 流程图（传统）。
* 伪代码（类似高级语言，但更灵活）。
* 计算机高级语言 (C, Pascal, C++, Java 等)。 [cite: 32]

### 4.4 算法的设计要求 (P27) [cite: 32]

1.  **正确性 (Correctness)**：算法应能正确解决求解问题。 [cite: 32] 经得起一切（合法的）输入数据的考验。 [cite: 32]
    * 层次：程序语法无误 -> 对几组典型输入能得到满意结果 -> 对精心选择的苛刻、边界数据也能得到满意结果 -> 对一切合法输入都能得到正确结果。
2.  **可读性 (Readability)**：算法应便于人们阅读、理解和交流。 [cite: 32] 注意注释。 [cite: 32]
3.  **健壮性 (Robustness)**：当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果或崩溃。 [cite: 32]
4.  **高效率与低存储量需求 (Efficiency & Low Storage Requirement)**： [cite: 32]
    * **效率**：指算法执行时间。 [cite: 32] 执行时间短，效率高。
    * **存储量**：指算法执行过程中所需的最大存储空间。
    * 通常这两者是矛盾的，需要权衡（时间换空间，空间换时间）。 [cite: 32]

### 4.5 算法的分类 (P28) [cite: 33]

* 试探、穷举 [cite: 33]
* **贪心法 (Greedy Method)**：分步完成，每步选择局部最优，期望得到整体最优。 [cite: 33]（如 P11 着色问题求解 [cite: 13, 33]）
* **分治法 (Divide and Conquer)**：将问题分解为若干个规模较小的相同问题，分别解决，然后合并结果。 [cite: 33]（如折半检索 [cite: 33]）
* **动态规划法 (Dynamic Programming)**：将问题分解，得到各个子问题的解，自底向上求解最终结果。 [cite: 33]（如 Floyd 最短路径 [cite: 33]）
* **回溯法 (Backtracking)**：深度优先搜索，不满足则退回尝试其他路径。 [cite: 33]（如迷宫问题 [cite: 33]）
* **分支界限法 (Branch and Bound)**：广度优先搜索，结合限界函数。 [cite: 33]（如农夫过河问题 [cite: 33]）

### 4.6 算法的评价指标 (P29) [cite: 34]

* **时间效率 (Time Efficiency)**：执行算法耗费的时间。 [cite: 34]
* **空间效率 (Space Efficiency)**：运行算法需要耗费的存储空间（主要考虑辅助空间）。 [cite: 34]
* 理解、阅读、编写、调试的难易程度等。 [cite: 34]

### 4.7 时间效率度量方法 (P29-P32)

* **事后统计**：通过实际运行程序来计时。
    * *缺点：受硬件、编程语言、编译器等多种因素影响，难以准确比较算法本身的优劣。*
* **事前分析估算**：去除具体机器和软件的因素，估算算法的运行时间。
    * **核心思想**：算法的执行时间主要取决于算法中**基本操作的执行次数 (频度)**。
    * **基本操作**：算法中执行次数最多的语句，通常是最内层循环的语句。 [cite: 38]
    * 算法的执行时间 = $\sum (\text{语句的执行次数} \times \text{语句执行一次所需的时间})$ [cite: 34]
    * 由于语句执行一次的时间与机器相关，我们关注**语句的执行次数**，特别是**基本操作的执行次数**。 [cite: 35]
* **时间复杂度 (Time Complexity)**：
    * 将基本操作的执行次数表示为问题规模 `n` 的函数 $T(n)$。
    * 当 `n` 趋向无穷大时，$T(n)$ 的数量级（阶）称为算法的**渐进时间复杂度 (Asymptotic Time Complexity)**，简称时间复杂度。 [cite: 37]
    * 记作：$T(n) = O(f(n))$ [cite: 37]
        * 表示存在正常数 `c` 和 `n0`，使得当 $n \ge n0$ 时，都有 $T(n) \le c \times f(n)$。 [cite: 37]
        * $O$ 的含义是 $T(n)$ 的数量级（增长率）与 $f(n)$ 相同。 [cite: 37]
    * **如何选择基本操作？** 通常是循环最内层的操作。 [cite: 38]
    * **常见的时间复杂度 (按数量级递增) (P31 图1.3)**： [cite: 38]
        * $O(1)$：常数阶 (Constant) [cite: 38]
        * $O(\log_2 n)$：对数阶 (Logarithmic) [cite: 38]
        * $O(n)$：线性阶 (Linear) [cite: 38]
        * $O(n \log_2 n)$：线性对数阶 [cite: 38]
        * $O(n^2)$：平方阶 (Quadratic) [cite: 38]
        * $O(n^3)$：立方阶 (Cubic) [cite: 38]
        * $O(n^k)$：k次方阶 (Polynomial) [cite: 38]
        * $O(k^n)$：指数阶 (Exponential) [cite: 38]
        * $O(n!)$：阶乘阶
    * **$O$ 表示法的运算规则 (P32)**： [cite: 39]
        * **加法规则**：$O(f_1(n)) + O(f_2(n)) = O(\max(f_1(n), f_2(n)))$ (取阶数高的) [cite: 39]
        * **乘法规则**：$O(f_1(n)) \times O(f_2(n)) = O(f_1(n) \times f_2(n))$ [cite: 39]
    * **最好、最坏、平均时间复杂度**： [cite: 39]
        * 有些算法的执行次数不仅与问题规模 `n` 有关，还与输入数据的初始状态有关。 [cite: 39]
        * **最坏时间复杂度**：在最坏情况下，算法的时间复杂度。 [cite: 39] 提供一个性能上界。
        * **平均时间复杂度**：在所有可能的输入实例以等概率出现的情况下，算法的期望运行时间。 [cite: 39]
        * **最好时间复杂度**：在最好情况下，算法的时间复杂度。意义不大，除非最好情况经常发生。
        * **通常我们关注最坏时间复杂度或平均时间复杂度。** [cite: 39]

* **代码示例与时间复杂度分析 (P30, P33-P34)**：

    * **例1 (P30, 矩阵乘法核心部分简化)**： [cite: 35, 36]
        ```c
        // 假设 c, a, b 都是 n x n 矩阵
        for (i=1; i<=n; i++) {         // n+1 次 (或 n 次，取决于判断条件) [cite: 35]
            for (j=1; j<=n; j++) {     // n * (n+1) 次 [cite: 35]
                c[i][j] = 0;           // n * n 次 [cite: 35]
                for (k=1; k<=n; k++) { // n * n * (n+1) 次 [cite: 35]
                    c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n * n * n 次 (基本操作) [cite: 36]
                }
            }
        }
        // T(n) = n*n*n (主要部分) + 其他低阶项
        // T(n) = O(n^3) [cite: 36]
        ```
        *PDF P30 给出的 $T(n)=2n^{3}+3n^{2}+2n+1$ 是更详细的计数，但最终也是 $O(n^3)$。 [cite: 36]*

    * **例2 (P33 (1))**: [cite: 40]
        ```c
        for (i=0; i<n; i++)
            for (j=0; j<n; j++)
                A[i][j] = 0; // 基本操作执行 n*n 次
        // T(n) = O(n^2) [cite: 40]
        ```

    * **例3 (P33 (2))**: [cite: 40]
        ```c
        s=0;
        for (i=0; i<n; i++)
            for (j=0; j<n; j++)
                for (k=0; k<n; k++)
                    s = s + B[i][j][k]; // 基本操作执行 n*n*n 次
        sum = s;
        // T(n) = O(n^3) [cite: 40]
        ```

    * **例4 (P33 (3))**: [cite: 40, 41]
        ```c
        i=s=0; [cite: 40]
        while (s<n) { // 循环次数 m [cite: 41]
            i++; [cite: 41]
            s += i; // s = 1+2+...+m = m(m+1)/2 [cite: 41]
        }
        // 循环条件是 s < n，即 m(m+1)/2 < n
        // 近似为 m^2 / 2 < n  => m^2 < 2n => m < sqrt(2n)
        // T(n) = O(sqrt(n)) 或 O(n^(1/2)) [cite: 41]
        ```

    * **例5 (P33 (4))**: [cite: 41]
        ```c
        i=1;
        while (i <= n)
            i = i * 2; // 假设循环 m 次
        // i 的值为 1, 2, 4, 8, ..., 2^(m-1)
        // 循环条件是 2^(m-1) <= n
        // (m-1) <= log2(n) => m <= log2(n) + 1
        // T(n) = O(log2(n)) [cite: 41]
        ```

    * **例6 (P34 (5))**: [cite: 42]
        ```c
        x=91; y=100; [cite: 42]
        while (y > 0) { [cite: 42]
            if (x > 100) { [cite: 42]
                x = x - 10; y--; [cite: 42]
            } else {
                x++; [cite: 42]
            }
        }
        // 循环次数不依赖于问题规模 n (这里没有n)。
        // y 从 100 减到 0，最多循环约 100 * (100/10) = 1000 次 (粗略估计，实际更复杂但仍是常数)。
        // 这是一个固定次数的循环。
        // T(n) = O(1) [cite: 42]
        ```
        *这个例子说明，即使循环看起来复杂，如果其执行次数不随问题规模 `n` 变化，时间复杂度也是 $O(1)$。 [cite: 42]*

### 4.8 空间效率度量 (P32) [cite: 39]

* **空间复杂度 (Space Complexity)**：$S(n) = O(f(n))$ [cite: 39]
* 算法的存储空间包括： [cite: 39]
    1.  存储算法本身所占用的空间（指令、常数、变量等）。
    2.  算法的输入、输出数据占用的空间。
    3.  程序执行过程中占用的**临时辅助空间 (Auxiliary Space)**。
* **通常，空间复杂度主要指算法在运行时所需要的辅助空间的大小。** [cite: 39]
* **原地工作 (In-place)**：如果算法所需的辅助空间是常数，即 $O(1)$，则称此算法为原地工作。

## 5. 总结 (P36) [cite: 44]

* **求解问题步骤**：问题抽象 -> 设计数据结构与算法 -> 编码 -> 测试。 [cite: 44]
* **数据结构**：数据的逻辑结构、存储结构和数据的运算。 [cite: 44]
    * 逻辑结构：集合、线性、树、图。 [cite: 44]
    * 存储结构：顺序、链接、索引、散列。 [cite: 44]
    * 算法设计取决于逻辑结构，实现依赖于存储结构。 [cite: 44]
* **抽象数据类型 (ADT)**：数学模型 + 定义在该模型上的一组操作。 [cite: 44]
* **算法**： [cite: 44]
    * 定义、特性（有穷、确定、可行、输入、输出）。 [cite: 44]
    * 设计要求（正确、可读、健壮、高效低存）。 [cite: 44]
    * 时间效率 $T(n)=O(f(n))$，空间效率 $S(n)=O(g(n))$，两者常相互制约。 [cite: 44]

---

**考试重点提示：**

* **基本概念的准确理解和区分**：数据、数据元素、数据项、数据对象、数据类型、数据结构（逻辑结构 vs 存储结构）。
* **四种逻辑结构和四种存储结构的特点、优缺点及适用场景。**
* **抽象数据类型 (ADT) 的概念和表示方法。**
* **算法的五个特性和四个设计要求。**
* **时间复杂度的计算和比较是绝对的重点和难点！**
    * 能够分析简单代码片段的时间复杂度（如 P33-P34 的例子）。
    * 理解 $O(1), O(\log n), O(n), O(n \log n), O(n^2), O(n^3), O(2^n)$ 等常见复杂度的含义和增长趋势。
    * 理解最坏、平均时间复杂度的概念。
* **空间复杂度的概念和简单分析。**

# 数据结构第二章 线性表 - 期末复习笔记

## 2.1 线性表的概念 (P1, P3-P4)

* **线性结构特点 (P1)**：
    1.  存在唯一的“第一个”数据元素。
    2.  存在唯一的“最后一个”数据元素。
    3.  除第一个元素外，每个元素均只有一个“直接前驱”。
    4.  除最后一个元素外，每个元素均只有一个“直接后继”。
    * *常用线性结构：线性表、栈、队列、串等。*

* **线性表 (Linear List) (P3)**：
    * 简称“表”，是零个或多个数据元素的**有穷序列**。
    * 通常表示为：$(k_0, k_1, ..., k_{n-1})$，其中 $n \ge 0$。
    * **表长 (Length)**：线性表中数据元素的个数 $n$。
    * **空表 (Empty List)**：长度为零的线性表 ($n=0$)。
    * **表目 (Element/Item)**：线性表中的数据元素（可包含多个数据项，也称记录）。
    * $k_0$ 是第一个元素（无前驱），$k_{n-1}$ 是最后一个元素（无后继）。
    * 对于 $0 \le i < n-1$，$k_i$ 是 $k_{i+1}$ 的直接前驱，$k_{i+1}$ 是 $k_i$ 的直接后继。

* **线性表的基本运算 (逻辑定义) (P4)**：
    * `InitList()`: 创建空线性表。
    * `DestroyList()`: 销毁线性表。
    * `ListEmpty()`: 判别线性表是否为空表。
    * `ListLength()`: 求线性表的长度。
    * `GetElem(L, i, &e)`: 获取线性表 L 中第 i 个元素，用 e 返回。
    * `LocateElem(L, e, compare())`: 查找元素 e 在线性表 L 中的位置（满足特定比较函数）。
    * `PriorElem(L, cur_e, &pre_e)`: 获取元素 cur_e 的直接前驱。
    * `NextElem(L, cur_e, &next_e)`: 获取元素 cur_e 的直接后继。
    * `ListInsert(&L, i, e)`: 在线性表 L 的第 i 个位置插入元素 e。
    * `ListDelete(&L, i, &e)`: 删除线性表 L 的第 i 个元素，并用 e 返回其值。
    * `TraverseList(L, visit())`: 遍历线性表。

* **线性表特点 (P4)**：关系简单、操作灵活，其长度可以增长、缩短。
* **存储结构 (P4)**：顺序存储、链接存储。

## 2.2 线性表的顺序表示和实现 (顺序表) (P5-P13)

* **定义 (P5)**：将线性表中的元素一个接一个地存储在**一片地址连续的存储单元**中。
* **逻辑关系表达 (P5)**：以元素在计算机内存中的“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。
    * `Locate(k_{i+1}) = Locate(k_i) + sizeof(DataType)`
    * `Locate(k_i) = Locate(k_0) + sizeof(DataType) * i`
* **随机存取 (Random Access)**：只要确定了首地址，线性表中任意数据元素都可以随机存取。因此，顺序表是“随机存取的存储结构”。
    * \[图片：顺序表存储示意图 P5\]

* **顺序表的C语言定义 (P7-P8)**：
    ```c
    #define MAXNUM <最多允许的数据元素个数> // 预定义常量

    // 方式一 (有缺陷)
    // DataType element[MAXNUM];
    // int n; // 表的当前长度

    // 方式二 (结构体封装)
    typedef struct SeqList {
        DataType element[MAXNUM]; // 存储元素的数组
        int n;                    // 当前表中元素的个数 (n < MAXNUM)
    } SeqList, *PSeqList;

    // 示例: PSeqList palist;
    // palist->n;
    // palist->element[0];
    ```
    * \[图片：顺序表结构示意图 P8，显示已用空间和剩余空间\]

* **顺序表基本运算的实现 (P9-P10)**：
    * **创建 (Create)**：分配内存，初始化 `n=0`。
    * **取值 (GetElem)**：通过下标直接访问 `element[i-1]` (假设i从1开始)。时间复杂度 $O(1)$。
    * **查找 (LocateElem)**：从头到尾逐个比较。平均时间复杂度 $O(n)$。
    * **插入 (ListInsert) (P9, P10图示)**：
        * 在位置 `p` (0-indexed) 插入元素 `x`。
        * **步骤**：
            1.  检查插入位置的合法性 ($0 \le p \le n$) 和表是否已满。
            2.  将 $k_p, k_{p+1}, ..., k_{n-1}$ 依次向后移动一个位置，变为 $k_{p+1}, k_{p+2}, ..., k_n$。
            3.  将 `x` 放入位置 `p`。
            4.  表长 `n` 增加 1。
        * **移动元素个数**：$n-p$ 个。
        * **最坏情况** (插入到表头 $p=0$)：移动 $n$ 个元素。
        * **最好情况** (插入到表尾 $p=n$)：移动 $0$ 个元素。
    * **删除 (ListDelete) (P9, P10图示)**：
        * 删除位置 `p` (0-indexed) 的元素。
        * **步骤**：
            1.  检查删除位置的合法性 ($0 \le p < n$) 和表是否为空。
            2.  (可选) 取出被删除元素。
            3.  将 $k_{p+1}, k_{p+2}, ..., k_{n-1}$ 依次向前移动一个位置，覆盖 $k_p, k_{p+1}, ..., k_{n-2}$。
            4.  表长 `n` 减少 1。
        * **移动元素个数**：$n-1-p$ 个。
        * **最坏情况** (删除表头 $p=0$)：移动 $n-1$ 个元素。
        * **最好情况** (删除表尾 $p=n-1$)：移动 $0$ 个元素。
    * **判空 (ListEmpty)**：判断 `n == 0`。时间复杂度 $O(1)$。

* **插入、删除元素时的时间效率分析 (P11-P12)**：
    * 假设等概率在第 $i$ 个元素前插入 ($0 \le i \le n$)，概率 $p_i = \frac{1}{n+1}$。
    * 插入平均移动次数 $E_{is} = \sum_{i=0}^{n} p_i (n-i) = \frac{1}{n+1} \sum_{j=0}^{n} j = \frac{n}{2}$。时间复杂度 $O(n)$。
    * 假设等概率删除第 $i$ 个元素 ($0 \le i < n$)，概率 $q_i = \frac{1}{n}$。
    * 删除平均移动次数 $E_{ds} = \sum_{i=0}^{n-1} q_i (n-1-i) = \frac{1}{n} \sum_{j=0}^{n-1} j = \frac{n-1}{2}$。时间复杂度 $O(n)$。
    * **结论**：插入、删除一个数据元素平均需要移动大约一半数量的数据元素，效率较低。
    * **定位运算**：平均需要 $n/2$ 次比较，时间复杂度 $O(n)$。
        * 对于**有序表**，可采用**折半查找**，时间复杂度 $O(\log_2 n)$。

* **顺序表空间的扩展 (P13)** (动态分配时)：
    * 当 `n == MAXNUM` 时，若要插入新元素，需要扩展存储空间。
    * **步骤**：
        1.  增加 `MAXNUM` 的值 (如 `pSeq->MAXNUM = 2 * pSeq->MAXNUM;`)。
        2.  使用 `malloc` (或 `realloc`) 申请新的、更大的连续存储空间。
        3.  检查是否申请成功。
        4.  使用 `memcpy` (或循环) 将原空间的数据复制到新空间。
        5.  使用 `free` 释放原存储空间。
        6.  更新指向元素数组的指针 `pSeq->element = NE;`。

* **顺序表的优缺点**：
    * **优点**：
        * 可以随机存取元素，访问效率高 ($O(1)$)。
        * 存储密度高（不需要额外空间指示逻辑关系，除了结构体本身开销）。
        * 逻辑简单，易于实现。
    * **缺点**：
        * 插入和删除操作需要移动大量元素，效率低 ($O(n)$)。
        * 需要预先分配连续的存储空间，若分配过大则浪费空间，过小则易发生溢出（对于静态分配）。
        * 动态扩展容量时有一定开销。

## 2.3 线性表的链接表示及实现 (链表) (P14-P36)

* **动机 (P14)**：克服顺序表插入删除效率低和空间固定/扩展不便的缺点。
    * 不要求逻辑上相邻的元素在物理位置上也相邻。
    * 通过附加的**指针**来表达数据元素之间的逻辑关系。
    * 失去了随机存取的优点。

### 2.3.1 单链表 (Singly Linked List) (P16-P24)

* **结点 (Node) 定义 (P16)**：数据元素的存储映像，由两部分构成：
    1.  **数据域 (Data Field)**：存放数据元素信息。
    2.  **指针域 (Pointer Field / Link Field)**：存放指向其直接后继结点的地址（指针）。
    * \[图片：单链表结点结构 P16\]

* **头指针 (Head Pointer) (P16)**：指向链表中第一个结点的指针。
    * 若链表为空，则头指针为 `NULL`。
* **头结点 (Head Node) (P17)**：在链表的第一个实际数据元素结点之前附加的一个结点，其数据域可以不存储任何信息（或存储表长等辅助信息），指针域指向第一个实际数据元素结点。
    * **引入头结点的好处**：
        * 使得对第一个元素结点的操作（插入/删除）与对其他结点的操作相统一，无需特殊处理。
        * 无论链表是否为空，头指针都指向头结点，不为 `NULL`，简化空表判断和操作。
    * \[图片：带头结点和不带头结点的单链表 P17\]

* **单链表的C语言定义 (P18)**：
    ```c
    typedef struct Node {
        DataType info;        // 数据域
        struct Node *link;    // 指针域，指向下一个Node类型的结点
    } Node, *PNode;           // Node是结构体类型名, PNode是指向Node的指针类型名

    // 如果要封装链表类型 (可选，但推荐)
    typedef struct LinkList {
        PNode head;           // 头指针 (若无头结点，指向第一个数据结点；若有头结点，指向头结点)
        // int length;        // 可以增加表长等其他信息
    } LinkList, *PLinkList;

    // 示例: PLinkList plist;
    // plist->head;
    ```

* **单链表基本运算 (P20)**：
    * `CreateNull_Link()`: 创建空链表（可能包括创建头结点）。
    * `IsNull_Link()`: 判空。
        * 无头结点：`plist->head == NULL`。
        * 有头结点：`plist->head->link == NULL`。
    * `Find_Link(plist, i)`: 查找第 `i` 个结点，返回其指针。需要从头遍历，时间复杂度 $O(i)$ 或 $O(n)$。
    * `Locate_Link(plist, x)`: 查找值为 `x` 的结点。时间复杂度 $O(n)$。
    * **插入结点 (Insert_Link) (P21图示)**：在指针 `p` 指向的结点之后插入一个新结点 `s` (值为 `x`)。
        * **步骤 (假设p已定位好)**：
            1.  `s = (PNode)malloc(sizeof(Node));` // 申请新结点空间
            2.  `s->info = x;`                     // 设置新结点数据域
            3.  `s->link = p->link;`               // ① 新结点的指针域指向p原先的后继
            4.  `p->link = s;`                     // ② p的指针域指向新结点s
        * **注意**：步骤 ① 和 ② 的顺序不能颠倒（若先执行②，会丢失p原先的后继）。
        * **时间复杂度**：若p已给出，为 $O(1)$。若需定位p，则为 $O(n)$。
        * **在第i个位置插入**：需要先找到第 $i-1$ 个结点。
    * **删除结点 (Delete_Link) (P21图示)**：删除指针 `p` 指向的结点的**后继**结点 `q`。
        * **步骤 (假设p已定位好，且p的后继存在)**：
            1.  `q = p->link;`                     // q指向待删除结点
            2.  `p->link = q->link;`               // p的指针域指向q的后继 (即p->link->link)
            3.  `free(q);`                         // 释放q所占空间
        * **时间复杂度**：若p已给出，为 $O(1)$。若需定位p，则为 $O(n)$。
        * **删除第i个结点**：需要先找到第 $i-1$ 个结点。
    * **单链表的建立 (Create_Link)**：
        * **头插法**：新结点总是插入到链表头部。读入顺序与链表中元素顺序相反。
        * **尾插法**：新结点总是插入到链表尾部。需要一个尾指针始终指向最后一个结点。读入顺序与链表中元素顺序相同。

* **结点插入和删除运算中的问题 (P22)**：
    * **带头结点 vs 不带头结点**：带头结点可以统一对第一个元素和非第一个元素的操作。
    * **结点的生成与删除**：动态生成 `malloc`，删除 `free`。
    * **时间复杂度**：
        * “条件插入/删除”（按值或按位置查找再操作）：主要时间花在定位上，为 $O(n)$。
        * 在已知指针 `p` 的**后继**位置插入/删除：时间复杂度为 $O(1)$。

* **单链表与顺序表的比较 (P23)**：
    | 特性         | 顺序表 (Sequential List)              | 单链表 (Singly Linked List)             |
    | :----------- | :------------------------------------ | :-------------------------------------- |
    | **存储分配** | 连续存储，静态分配或动态扩展        | 离散存储，动态分配结点                  |
    | **存储密度** | 高 (1，若不计结构体开销)             | 低 (d = 数据空间/总空间 < 1，因有指针域) |
    | **随机存取** | 支持 ($O(1)$)                         | 不支持 (需从头遍历 $O(n)$)             |
    | **插入/删除**| 慢 ($O(n)$，需移动元素)                | 快 ($O(1)$，若已知前驱；否则 $O(n)$ 定位) |
    | **空间利用** | 可能浪费或溢出 (静态)                 | 灵活，按需分配                          |

* **单链表与顺序表的选择 (P24)**：
    * **频繁访问**：选顺序表。
    * **频繁插入/删除**：选链表。
    * **表长变化**：
        * 难以事先估计，或变化大：选链表。
        * 基本固定或变化不大：可选顺序表。
    * **语言支持**：若语言不支持动态分配 (如旧版Fortran, Basic)，只能选顺序表。

### 2.3.2 静态链表 (Static Linked List) (P25-P30)

* **动机**：在不支持指针或动态内存分配的语言中，用数组来模拟链式存储。
* **结构 (P25)**：
    * 用一个较大的数组 `SLinkList[MaxSize]` 来存储结点。
    * 数组的每个元素 `Component` 包含两部分：
        * `data`: 数据域。
        * `cursor`: **游标**，代替指针，存放下一个元素在数组中的**下标**。若为0，通常表示链表结束或指向备用链表头。
    * \[图片：静态链表结点结构 P25\]
* **管理方式 (P26, P29)**：
    * 通常将数组的第一个元素 `list[0]` 和最后一个元素 `list[MaxSize-1]` 作为特殊用途的头结点（一个用于已用链表，一个用于备用/空闲链表）。
    * **工作链表 (已用链表)**：存放实际数据的链表。
    * **备用链表 (空闲链表)**：将数组中所有未被占用的空间链接起来形成的链表。
    * `list[0].cursor`：指向工作链表的第一个结点下标，或指向备用链表的第一个空闲结点下标。
    * \[图片：静态链表示例 P28, 工作链表+备用链表 P29\]
* **基本操作 (P29-P30)**：
    * `InitList(list)`: 初始化静态链表，将所有结点连接成一个备用链。
        ```c
        void InitList(SLinkList list) {
            for (int i = 0; i < MaxSize - 1; i++) {
                list[i].cursor = i + 1;
            }
            list[MaxSize - 1].cursor = 0; // 备用链表尾
            // list[0] 通常作为备用链表的头指针，所以 list[0].cursor 指向第一个空闲位置
            // 工作链表的头指针可以另设，或者也用 list[0] 的某个域
        }
        ```
    * `Malloc_SL(list)`: 从备用链中申请空间（取出一个空闲结点），返回其下标。
        ```c
        int Malloc_SL(SLinkList list) { // 假设 list[0].cursor 指向备用链表头
            int i = list[0].cursor;
            if (list[0].cursor != 0) { // 备用链非空
                list[0].cursor = list[i].cursor; // 更新备用链表头
            }
            return i; // 返回分配到的结点下标，若i=0则分配失败
        }
        ```
    * `Free_SL(list, k)`: 释放下标为 `k` 的结点，将其连接到备用链的头部。
        ```c
        void Free_SL(SLinkList list, int k) { // 假设 list[0].cursor 指向备用链表头
            list[k].cursor = list[0].cursor;
            list[0].cursor = k;
        }
        ```
    * 插入、删除操作通过修改游标完成，类似于单链表的指针修改。
* **优点**：在不支持指针的语言中实现了链式存储的灵活性。
* **缺点**：
    * 没有解决顺序存储中容量固定的问题（数组大小仍需预先确定）。
    * 失去了顺序存储的随机存取特性。

### 2.3.3 循环链表 (Circular Linked List) (P31-P32)

* **定义 (P31)**：将单链表中最后一个结点的指针域指向链表中的第一个结点（或头结点，如果有的话），构成一个环形。
* **优点 (P31)**：从表中任一结点出发，都可以遍历到整个链表的所有结点。
* **判空条件**：
    * 无头结点：`pclist->head == NULL` (或者特殊约定)。
    * 带头结点：`pclist->head->link == pclist->head` (头结点的指针指向自身)。
* **遍历终止条件 (P31)**：
    * 无头结点，`head` 指向第一个：`p->link == head` (p 访问到最后一个结点时)。
    * 带头结点，`head` 指向头结点：`p->link == head` (p 访问到最后一个数据结点时) 或 `p == head` (p 再次回到头结点时)。
* **改进 (P32)**：让尾指针 `rear` (或 `pclist->head` 在某些实现中) 指向链表的**最后一个结点**。
    * **好处**：
        * 访问第一个结点：`rear->link` (若无头结点) 或 `rear->link->link` (若有头结点，且头结点是 `rear->link`)。
        * 访问最后一个结点：`rear`。
        * 方便将两个循环链表合并：将一个链表的尾部连接到另一个链表的头部，只需修改少量指针。
    * \[图片：循环链表，头指针指向最后一个结点 P32\]

### 2.3.4 双向链表 (Doubly Linked List) (P33-P36)

* **动机 (P33)**：单链表找后继容易 ($O(1)$)，找前驱困难 ($O(n)$)。双向链表使得找前驱和后继都容易。
* **结点结构 (P33)**：每个结点包含三个域：
    * `llink` (left link / prior pointer)：指向其直接前驱结点的指针。
    * `info`：数据域。
    * `rlink` (right link / next pointer)：指向其直接后继结点的指针。
    * \[图片：双向链表结点结构 P33\]
* **C语言定义 (P34)**：
    ```c
    typedef struct DoubleNode {
        DataType info;
        struct DoubleNode *llink, *rlink;
    } DoubleNode, *PDoubleNode;

    // 可选的链表封装
    typedef struct DoubleList {
        PDoubleNode head; // 指向第一个结点 (或头结点)
        PDoubleNode rear; // (可选) 指向最后一个结点
        // int length;
    } DoubleList, *PDoubleList;
    ```
* **重要特性 (P34)**：对于任意非首尾结点 `p` (或在循环链表中任意结点)：
    `p->rlink->llink == p`
    `p->llink->rlink == p`

* **双向链表的插入 (P36图示)**：在结点 `p` **之前**插入新结点 `s`。
    * **步骤** (假设 `p` 已知，且 `p` 不是第一个结点或有头结点)：
        1.  `s->rlink = p;`
        2.  `s->llink = p->llink;`
        3.  `p->llink->rlink = s;` (如果 `p->llink` 存在)
        4.  `p->llink = s;`
    * **顺序很重要，通常先连s，再断开旧连接。**
    * 时间复杂度：$O(1)$ (若p已知)。

* **双向链表的删除 (P36图示)**：删除结点 `p`。
    * **步骤** (假设 `p` 已知)：
        1.  `p->llink->rlink = p->rlink;` (如果 `p->llink` 存在)
        2.  `p->rlink->llink = p->llink;` (如果 `p->rlink` 存在)
        3.  `free(p);`
    * 时间复杂度：$O(1)$ (若p已知)。

* **双向循环链表 (Doubly Circular Linked List) (P35)**：
    * 将双向链表的头和尾连接起来。
    * 最后一个结点的 `rlink` 指向头结点（或第一个数据结点）。
    * 第一个结点的 `llink` 指向尾结点（或头结点）。
    * **带头结点的双向循环链表 (P35图示)**：
        * 头结点的 `rlink` 指向第一个数据结点。
        * 头结点的 `llink` 指向最后一个数据结点。
        * 第一个数据结点的 `llink` 指向头结点。
        * 最后一个数据结点的 `rlink` 指向头结点。
        * **判空**：`pdlist->head->rlink == pdlist->head` (或 `pdlist->head->llink == pdlist->head`)。

## 2.4 应用举例 (P37-P41)

### 2.4.1 Josephus 问题 (约瑟夫环) (P37-P40)

* **问题描述 (P37)**：n 个人围成一圈，从第 s 个人开始报数，数到第 m 的人出列；然后从出列的下一个人重新开始报数，数到第 m 的人又出列；如此反复直到所有人都出列。求出列次序。
    * \[图片：Josephus问题求解过程示例 P38-P39\]

* **顺序表方式实现 (P40)**：
    * 用数组存储人。
    * 出列操作：标记或实际删除元素（后者涉及元素移动）。
    * **时间复杂度**：若每次删除都移动元素，则为 $O(n^2)$。因为每次出列后，数组中元素个数减少，报数和删除的代价是 $(n-1) + (n-2) + ... + 1$ 次移动（最坏情况）和 $n \times m$ 次查找（粗略）。
    * 报数逻辑：`(current_pos + m - 1) % current_length`。

* **循环链表方式实现 (P40)**：
    * 用循环单链表（通常带头结点）表示圆桌。
    * **步骤**：
        1.  建立循环链表 ($O(n)$)。
        2.  找到第 s 个结点开始报数 ($O(s)$ 或 $O(n)$)。
        3.  重复 n 次：
            * 从当前结点开始向后走 $m-1$ 步找到要出列的结点的前驱。
            * 删除该结点（修改指针 $O(1)$）。
            * 输出。
    * **时间复杂度**：总共需要 $n$ 次出列，每次出列需要报数 $m$ 次（在链表中移动 $m-1$ 步）。所以大致为 $O(n \times m)$。
    * 比顺序表（移动元素版）效率高，特别是当 $m$ 较小时。

### 2.4.2 一元多项式表示与实现 (P41)

* **一元多项式**：$P_n(x) = p_0 + p_1 x + p_2 x^2 + ... + p_n x^n$
* **顺序表表示**：
    * 数组下标代表指数，数组元素存系数。
    * $P = (p_0, p_1, p_2, ..., p_n)$。
    * **缺点**：对于稀疏多项式（如 $P(x) = 1 + 2x^{10000} + 4x^{40000}$），会浪费大量存储空间。
* **链表表示 (P41)**：
    * 每个结点存储一个**非零项**。
    * 结点结构：`(系数, 指数, 指针域)`。
    * 链表按指数升序（或降序）排列。
    * \[图片：一元多项式链表表示 P41\]
    * **优点**：只存储非零项，节省空间，尤其对稀疏多项式。
    * **多项式相加**：
        * 同时遍历两个多项式链表。
        * 比较当前结点的指数：
            * 若指数相同：系数相加。若和不为零，则生成新结点加入结果链表；若和为零，则舍弃。两个链表指针均后移。
            * 若指数不同：将指数较小的项复制到结果链表，该链表指针后移。
        * 处理剩余未比较的项。
        * 本质是两个有序单链表的合并问题。

## 总结与考试重点

* **线性表的逻辑定义**：有穷序列，一对一关系。
* **顺序表**：
    * 定义、存储方式（连续）、随机存取 $O(1)$。
    * 插入/删除操作（元素移动），时间复杂度 $O(n)$。
    * 优缺点。
* **链表 (单链表、循环链表、双向链表、静态链表)**：
    * **结点结构**：数据域、指针域（单链表一个，双向链表两个）。
    * **头指针、头结点**：作用和实现上的区别。
    * **插入/删除操作**：核心是**修改指针**，理解图示和指针修改顺序。
        * 单链表在p后插入/删除p的后继：$O(1)$。
        * 双向链表在p前/后插入，或删除p：$O(1)$。
        * 若涉及查找定位，则整体时间复杂度为 $O(n)$。
    * **各种链表的特点和适用场景**。
    * **静态链表**：用数组和游标模拟，理解其`Malloc`和`Free`思想。
* **顺序表 vs. 链表**：存储密度、存取方式、插入删除效率、空间分配的比较。
* **时间复杂度分析**：能够分析线性表各种操作在顺序存储和链式存储下的时间复杂度。
* **应用**：Josephus问题、一元多项式（理解为何用链表处理稀疏多项式）。
* **代码实现**：虽然考试可能不要求写完整代码，但要理解核心操作的伪代码或C片段，特别是链表的指针操作。

祝你期末考试顺利！
